# Java的内存回收

## 一、什么时候垃圾回收

### 1、对象已死？

当对象死去的时候进行垃圾回收，即对象失去引用的时候进行垃圾回收。**如何判断对象已经死去呢？**

+ 引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用时就加一，引用失效时就减一，为零的时候就进行垃圾回收。此方法的**缺点**是当有两个对象互相引用时，实际上这两个对象已经不再被访问，由于循环引用的存在，导致引用计数器恒不为零。
+ 可达性分析算法：通过一系列的被称为GC Roots的对象作为起始点，从这些起始点往下搜索，当一个对象到GC Roots没有任何引用链时，即对象不可达，则此对象可以进行回收

GC Roots包括以下几种：

+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法中JNI引用的对象（Native方法）

### 2、引用

引用包含以下几种：

+ 强引用
+ 软引用
+ 弱引用
+ 虚引用

### 3、对象不一定非死不可

真正宣告一个对象死亡至少经历两次标记过程：如果第一次找不到GC Roots，则判断是否需要进行finalize()方法，如果对象已经执行过finalize()或者finalize()已经被覆盖，则不用执行finalize()。对象在执行finalize()期间如果与引用链上的对象挂上钩则第二次标记时会将其清理出即将回收的集合，否则将被回收。

## 二、垃圾回收的对象是什么

所谓内存回收，当然是回收内存。Java运行时数据区主要分为以下几部分：

+ 程序计数器：当前线程所执行字节码的行号指示器，唯一不存在OOM的区域
+ 虚拟机栈：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。为字节码服务，即Java方法
+ 本地方法栈：为Native方法服务，与虚拟机栈功能类似
+ Java堆：在虚拟机启动时创建，存放对象实例，所有对象实例和数组都要在堆上分配
+ 方法区（永生代）：存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
+ 运行时常量池（包括在方法区中）：存放编译期生成的各种字面量与符号引用

1-3属于线程私有，4-6是线程共享数据区域，垃圾收集器关注的是数据共享部分的内存区域。**Java堆是内存回收的主要对象**

方法区的回收性价比不高，主要包括两部分内容：废弃常量和无用的类。废弃常量直接看是否有引用，而无用的类包括以下三种：

+ 该类所有实例都已经被回收，Java堆中没有任何相关实例
+ 加载该类的ClassLoader已被回收
+ 该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法

## 三、用什么垃圾回收算法

## 四、用什么垃圾回收器



## 五、结合垃圾回收，平时写代码有什么注意的地方

