# Java的内存回收

## 一、什么时候垃圾回收

1、当应用程序分配新的对象，GC的代的预算大小已经达到阈值，比如GC的第0代已满

2、代码主动显式调用System.GC.Collect()

3、其他特殊情况，比如，windows报告内存不足、CLR卸载AppDomain、CLR关闭，甚至某些极端情况下系统参数设置改变也可能导致GC回收

### 1、对象已死？

当对象死去的时候进行垃圾回收，即对象失去引用的时候进行垃圾回收。**如何判断对象已经死去呢？**

+ 引用计数算法：在对象中添加一个引用计数器，每当有一个地方引用时就加一，引用失效时就减一，为零的时候就进行垃圾回收。此方法的**缺点**是当有两个对象互相引用时，实际上这两个对象已经不再被访问，由于循环引用的存在，导致引用计数器恒不为零。
+ 可达性分析算法：通过一系列的被称为GC Roots的对象作为起始点，从这些起始点往下搜索，当一个对象到GC Roots没有任何引用链时，即对象不可达，则此对象可以进行回收

GC Roots包括以下几种：

+ 虚拟机栈（栈帧中的本地变量表）中引用的对象
+ 方法区中类静态属性引用的对象
+ 方法区中常量引用的对象
+ 本地方法中JNI引用的对象（Native方法）

### 2、引用

引用包含以下几种：

+ 强引用
+ 软引用
+ 弱引用
+ 虚引用

### 3、对象不一定非死不可

真正宣告一个对象死亡至少经历两次标记过程：如果第一次找不到GC Roots，则判断是否需要进行finalize()方法，如果对象已经执行过finalize()或者finalize()已经被覆盖，则不用执行finalize()。对象在执行finalize()期间如果与引用链上的对象挂上钩则第二次标记时会将其清理出即将回收的集合，否则将被回收。

## 二、垃圾回收的对象是什么

所谓内存回收，当然是回收内存。Java运行时数据区主要分为以下几部分：

+ 程序计数器：当前线程所执行字节码的行号指示器，唯一不存在OOM的区域
+ 虚拟机栈：每个方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。为字节码服务，即Java方法
+ 本地方法栈：为Native方法服务，与虚拟机栈功能类似
+ Java堆：在虚拟机启动时创建，存放对象实例，所有对象实例和数组都要在堆上分配
+ 方法区（永生代）：存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码
+ 运行时常量池（包括在方法区中）：存放编译期生成的各种字面量与符号引用

1-3属于线程私有，4-6是线程共享数据区域，垃圾收集器关注的是数据共享部分的内存区域。**Java堆是内存回收的主要对象**

方法区的回收性价比不高，主要包括两部分内容：废弃常量和无用的类。废弃常量直接看是否有引用，而无用的类包括以下三种：

+ 该类所有实例都已经被回收，Java堆中没有任何相关实例
+ 加载该类的ClassLoader已被回收
+ 该类对应的java.lang.Class对象没有在任何地方引用，无法在任何地方通过反射访问该类的方法

## 三、用什么垃圾回收算法

### 1、标记-清除算法

标记出需要回收的对象，标记完成后统一收集。

两个缺点：

+ 效率不高：标记和清除效率不高
+ 空间利用不强：标记清除后产生大量内存碎片，不利于内存分配

### 2、复制算法

为了解决效率问题，将可用内存划分为大小相同的两块，每次只用其中一块。一块用完之后再将对象复制到另外一块上，清除内存只需要清理一半。但是内存利用率不高。

目前采用此算法回收新生代，内存空间化为8份Eden，2份Survivor。当Survivor不够时，需要其他内存（老年代）进行分配担保

### 3、标记整理算法

根据老年代提出此算法，标记后将存活对象都向一端移动，然后清理掉边界以外的内存

### 4、分代收集算法

根据不同年代的特点采用最适当的收集算法。

## 四、用什么垃圾回收器

### 1、Serial收集器

单线程收集器，他在进行垃圾收集时，其他线程必须停止工作，Stop The World，适用于单个CPU的工作环境，没有线程交互的开销。对于运行在Client模式下的VM是很好的选择

### 2、ParNew收集器

Serial收集器的多线程版本，也是需要Stop The World，除了Serial之外，只有ParNew能够配合CMS工作

### 3、Parallel Scavenge收集器

新生代收集器，使用复制算法的收集器，关注点在于达到一个可控制的吞吐量，停顿时间越短越适合需要与用户交互的程序，高吞吐量则可以更高效地利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要交互太多的任务。GC的停顿时间缩短是牺牲吞吐量和新生代空间而换取。自适应调节策略是他与ParNew收集器的重要区别

### 4、Serial Old收集器

Serial收集器的老年代版本，Client模式下的VM使用，两个用途：一个是在JDK1.5之前的版本中与Parallel Scavenge收集器搭配使用，另一个用途是作为CMS收集器的备选方案

### 5、Parallel Old收集器

Parallel Scavenge收集器的老年代版本，使用多线程标记和标记整理算法。由于CMS无法在JDK1.5之后与Parallel Scavenge搭配使用，所以有了Parallel Old。

### 6、CMS收集器

关注点为尽可能缩短垃圾收集时用户线程停顿的时间，基于标记清除算法实现，分为以下四步：

+ 初始标记（Stop The World）：标记GC Roots能够关联到的对象
+ 并发标记
+ 重新标记（Stop The World）：修正并发标记期间程序继续运行而导致的对象标记变动
+ 并发清除

同时，CMS也有缺点：

+ 对CPU资源敏感：在并发阶段虽然不会导致用户线程停顿，但是因为占用一部分系统资源导致应用程序变慢，总吞吐量降低
+ 无法处理浮动垃圾：CMS收集器与用户线程并发进行，从而用户线程会产生新的垃圾，只能等待下一个GC清理。而且CMS需要留出一部分内存提供并发收集时的程序运行使用
+ CMS基于标记清除实现，会产生大量空间碎片，为了解决此问题，CMS提供内存整理功能

### 7、G1收集器

G1有计划的在Java堆中避免全区域的垃圾收集，跟踪每个Region的垃圾价值大小，在后台维护一个优先列表。优点如下：

+ 并行与并发：多CPU减少Stop The World的时间
+ 分代收集：采用不同的方式对待存活时间不同的对象
+ 空间整合：G1将Java堆划分为多个大小相等的Region，从局部看基于复制算法实现，收集后提供规整的可用内存，运作期间不产生内存空间碎片
+ 可预测的停顿：使用者可明确指定在某段时间内消耗在垃圾收集的时间不得超过多长时间

分为以下四步：

+ 初始标记
+ 并发标记
+ 最终标记
+ 筛选回收

## 五、内存分配策略

1、对象优先在Eden区分配，内存不够则Minor GC

2、大对象进入老年代

3、长期存活对象进行老年代：有个Age计数器，或者Survivor空间中相同年龄的对象总大小大于Survivor空间的一半，则Age>=该年龄的进入老年代

4、**空间分配担保**：在发生Minor GC之前，VM会检查老年代最大连续空间是否大于新生代所有对象总空间，否则不安全。有可能存在新生代存活率比较高的情况，此时需要老年代做担保，一般取之前每一次回收晋升老年代的平均值作为经验值，与老年代的剩余空间比较，看是Minor GC或是Full GC。


在发生Minor GC之前，虚拟机会检查老年代最大可用连续空间是否大于新生代所有对象的总空间，大的话可以保证安全，因为就算所有都进老年代也能容纳。老年代没有新生代可用空间大的话，虚拟机查看HandlePromotionFailure设置值是否允许担保失败。如果允许，继续检查老年代最大可用连续空间是否大于历次晋升到老年代对象的平均大小，大的话就执行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，就要改为进行一次FullGC。
冒险冒的什么风险？ 新生代使用复制算法，但是为了内存利用率，只使用其中一个Survivor空间作为轮换备份。因此在MinorGC之后仍有大量对象存活，就要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。

## 六、结合垃圾回收，平时写代码有什么注意的地方

由于GC的代价很大，平时开发中注意一些良好的编程习惯有可能对GC有积极正面的影响，否则有可能产生不良效果。

1、尽量不要new很大的object，大对象（>=85000Byte）直接归为G2代，GC回收算法从来不对大对象堆（LOH）进行内存压缩整理，因为在堆中下移85000字节或更大的内存块会浪费太多CPU时间

2、不要频繁的new生命周期很短object，这样频繁垃圾回收频繁压缩有可能会导致很多内存碎片，可以使用设计良好稳定运行的对象池（ObjectPool）技术来规避这种问题

3、使用更好的编程技巧，比如更好的算法、更优的数据结构、更佳的解决策略等等

## 七、java内存泄露

[java内存泄露](https://blog.csdn.net/mengxpfighting/article/details/82184396)

